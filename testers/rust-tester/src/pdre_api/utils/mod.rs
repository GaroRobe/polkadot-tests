mod crypto;
mod network;
mod storage;
mod child_storage;

pub use crypto::CryptoApi;
pub use network::NetworkApi;
pub use storage::StorageApi;
pub use child_storage::ChildStorageApi;

// Convenience function:
// Gets the Wasm blob which was generated by the `build.rs` script
fn get_wasm_blob() -> Vec<u8> {
    use std::fs::File;
    use std::io::prelude::*;

    let mut f = File::open("test/testers/rust-tester/target/wasm32-unknown-unknown/release/wasm_blob.wasm")
        .expect("Failed to open wasm blob in target");
    let mut buffer = Vec::new();
    f.read_to_end(&mut buffer)
        .expect("Failed to load wasm blob into memory");
    buffer
}

use substrate_executor::error::Error;
use substrate_executor::WasmExecutor;
use substrate_primitives::testing::KeyStore;
use substrate_primitives::Blake2Hasher;
use substrate_state_machine::TestExternalities as CoreTestExternalities;
use wasmi::RuntimeValue::{self, I32};
use wasmi::MemoryRef;

use std::cell::RefCell;
use std::rc::Rc;

type TestExternalities<H> = CoreTestExternalities<H, u64>;


struct CallWasm<'a> {
    ext: &'a mut TestExternalities<Blake2Hasher>,
    blob: &'a [u8],
    method: &'a str,
    create_param: Box<FnOnce(&mut dyn FnMut(&[u8]) -> Result<u32, Error>) -> Result<Vec<RuntimeValue>, Error>>,
}

impl<'a> CallWasm<'a> {
    fn gen_param_verify(&'a mut self, data: &[u8], output: &'a mut [u8]) -> AfterCallWasm<'a> {
        let data_c = data.to_owned();
        let output_c = output.to_owned();
        let ptr_holder: Rc<RefCell<u32>> = Rc::new(RefCell::new(0));

        AfterCallWasm::from(
            self,
            Box::new(
                move |alloc: &mut dyn FnMut(&[u8]) -> Result<u32, Error>| {
                    let data_offset = alloc(&data_c)?;
                    let output_offset = alloc(&output_c)?;
                    *ptr_holder.borrow_mut() = output_offset as u32;
                    Ok(vec![
                        I32(data_offset as i32),
                        I32(data_c.len() as i32),
                        I32(output_offset as i32),
                    ])
                }
            ),
            Some(ptr_holder),
            Some(output)
        )
    }
}

struct AfterCallWasm<'a> {
    ext: &'a mut TestExternalities<Blake2Hasher>,
    blob: &'a [u8],
    method: &'a str,
    create_param: Box<FnOnce(&mut dyn FnMut(&[u8]) -> Result<u32, Error>) -> Result<Vec<RuntimeValue>, Error>>,
    ptr_holder: Option<Rc<RefCell<u32>>>,
    output: Option<&'a mut [u8]>,
}

impl<'a> AfterCallWasm<'a> {
    fn from(w: &'a mut CallWasm<'a>,
        create_param: Box<FnOnce(&mut dyn FnMut(&[u8]) -> Result<u32, Error>) -> Result<Vec<RuntimeValue>, Error>>,
        ptr_holder: Option<Rc<RefCell<u32>>>,
        output: Option<&'a mut [u8]>,
    ) -> Self {
        AfterCallWasm {
            ext: w.ext,
            blob: w.blob,
            method: w.method,
            create_param: create_param,
            ptr_holder: ptr_holder,
            output: output,
        }
    }
    /// Calls the final Wasm Runtime function (this method does not get used directly)
    fn call_into_wasm<F, FR, R>(&mut self, create_param: F, filter_return: FR) -> Result<R, Error> where
		F: FnOnce(&mut dyn FnMut(&[u8]) -> Result<u32, Error>) -> Result<Vec<RuntimeValue>, Error>,
		FR: FnOnce(Option<RuntimeValue>, &MemoryRef) -> Result<Option<R>, Error>
    {
        WasmExecutor::new()
            .call_with_custom_signature(
                self.ext,
                1,
                self.blob,
                self.method,
                create_param,
                filter_return
            )
    }
    fn return_none(&mut self) {
        let temp = vec![0; self.output.unwrap().len()];
        self.call_into_wasm(self.create_param,
            |_, memory| {
                temp.copy_from_slice(
                    memory
                        .get(*self.ptr_holder.as_ref().unwrap().borrow(), 16)
                        .map_err(|_| Error::Runtime)?
                        .as_slice(),
                );
                Ok(Some(()))
            }
        );

        self.output.as_mut().unwrap().copy_from_slice(&temp);
    }
}