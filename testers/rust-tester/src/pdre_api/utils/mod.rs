mod crypto;
mod network;
mod storage;
mod child_storage;

pub use crypto::CryptoApi;
pub use network::NetworkApi;
pub use storage::StorageApi;
pub use child_storage::ChildStorageApi;

// Convenience function:
// Gets the Wasm blob which was generated by the `build.rs` script
fn get_wasm_blob() -> Vec<u8> {
    use std::fs::File;
    use std::io::prelude::*;

    let mut f = File::open("test/testers/rust-tester/target/wasm32-unknown-unknown/release/wasm_blob.wasm")
        .expect("Failed to open wasm blob in target");
    let mut buffer = Vec::new();
    f.read_to_end(&mut buffer)
        .expect("Failed to load wasm blob into memory");
    buffer
}

use substrate_executor::error::Error;
use substrate_executor::WasmExecutor;
use substrate_primitives::testing::KeyStore;
use substrate_primitives::Blake2Hasher;
use substrate_state_machine::TestExternalities as CoreTestExternalities;
use wasmi::RuntimeValue::{self, I32};
use wasmi::MemoryRef;

use std::cell::RefCell;
use std::rc::Rc;

type TestExternalities<H> = CoreTestExternalities<H, u64>;

fn wrap<T>(t: T) -> Rc<RefCell<T>> {
    Rc::new(RefCell::new(t))
}
fn copy(scoped: Rc<RefCell<Vec<u8>>>, output: &mut [u8]) {
    output.copy_from_slice(scoped.borrow().as_slice());
}

struct CallWasm<'a> {
    ext: &'a mut TestExternalities<Blake2Hasher>,
    blob: &'a [u8],
    method: &'a str,
    //create_param: Box<FnOnce(&mut dyn FnMut(&[u8]) -> Result<u32, Error>) -> Result<Vec<RuntimeValue>, Error>>,
}

impl<'a> CallWasm<'a> {
    fn new(
        ext: &'a mut TestExternalities<Blake2Hasher>,
        blob: &'a [u8],
        method: &'a str,
    ) -> Self {
        CallWasm {
            ext: ext,
            blob: blob,
            method: method,
        }
    }
    /// Calls the final Wasm Runtime function (this method does not get used directly)
    fn call<F, FR, R>(&mut self, create_param: F, filter_return: FR) -> Result<R, Error> where
		F: FnOnce(&mut dyn FnMut(&[u8]) -> Result<u32, Error>) -> Result<Vec<RuntimeValue>, Error>,
		FR: FnOnce(Option<RuntimeValue>, &MemoryRef) -> Result<Option<R>, Error>
    {
        WasmExecutor::new()
            .call_with_custom_signature(
                self.ext,
                1,
                self.blob,
                self.method,
                create_param,
                filter_return
            )
    }
    fn gen_params(data: &[&[u8]], len_index: &[usize])
        -> impl FnOnce(&mut dyn FnMut(&[u8]) -> Result<u32, Error>) -> Result<Vec<RuntimeValue>, Error>
    {
        let data_c: Vec<Vec<u8>> = data
            .iter()
            .map(|d| d.to_vec())
            .collect();
        let len_index_c = len_index.to_owned();

        move |alloc| {
            let mut offsets = vec![];
            for d in &data_c {
                offsets.push(alloc(d)?);
            }

            let mut counter = 0;
            let mut runtime_vals = vec![];
            for off in offsets {
                // Push the offset to vals
                runtime_vals.push(I32(off as i32));
                // If there also must be the length, push too
                if len_index_c.contains(&counter) {
                    runtime_vals.push(I32(data_c[counter].len() as i32))
                }
                counter += 1;
            }

            Ok(runtime_vals)
        }
    }
    fn with_data_output_ptr(data: &[u8], output: &[u8], ptr: Rc<RefCell<u32>>)
        -> impl FnOnce(&mut dyn FnMut(&[u8]) -> Result<u32, Error>) -> Result<Vec<RuntimeValue>, Error>
    {
        let data_c = data.to_owned();
        let output_c = output.to_owned();

        move |alloc| {
            let data_offset = alloc(&data_c)?;
            let output_offset = alloc(&output_c)?;
            *ptr.borrow_mut() = output_offset as u32;
            Ok(vec![
                I32(data_offset as i32),
                I32(data_c.len() as i32),
                I32(output_offset as i32),
            ])
        }
    }
    fn with_2x_data_output_ptr(data1: &[u8], data2: &[u8], output: &mut [u8], ptr: Rc<RefCell<u32>>)
        -> impl FnOnce(&mut dyn FnMut(&[u8]) -> Result<u32, Error>) -> Result<Vec<RuntimeValue>, Error>
    {
        let data1_c = data1.to_owned();
        let data2_c = data2.to_owned();
        let output_c = output.to_owned();

        move |alloc| {
            let data1_offset = alloc(&data1_c)?;
            let data2_offset = alloc(&data2_c)?;
            let output_offset = alloc(&output_c)?;
            *ptr.borrow_mut() = output_offset as u32;
            Ok(vec![
                I32(data1_offset as i32),
                I32(data2_offset as i32),
                I32(data2_c.len() as i32),
                I32(output_offset as i32),
            ])
        }
    }
    fn with_3x_data_output_ptr(data1: &[u8], data2: &[u8], data3: &[u8], output: &mut [u8], ptr: Rc<RefCell<u32>>)
        -> impl FnOnce(&mut dyn FnMut(&[u8]) -> Result<u32, Error>) -> Result<Vec<RuntimeValue>, Error>
    {
        let data1_c = data1.to_owned();
        let data2_c = data2.to_owned();
        let data3_c = data3.to_owned();
        let output_c = output.to_owned();

        move |alloc| {
            let data1_offset = alloc(&data1_c)?;
            let data2_offset = alloc(&data2_c)?;
            let data3_offset = alloc(&data3_c)?;
            let output_offset = alloc(&output_c)?;
            *ptr.borrow_mut() = output_offset as u32;
            Ok(vec![
                I32(data1_offset as i32),
                I32(data2_offset as i32),
                I32(data3_offset as i32),
                I32(data3_c.len() as i32),
                I32(output_offset as i32),
            ])
        }
    }
    fn return_none_write_buffer(output: Rc<RefCell<Vec<u8>>>, ptr: Rc<RefCell<u32>>)
	    -> impl FnOnce(Option<RuntimeValue>, &MemoryRef) -> Result<Option<()>, Error>
    {
        move |_, memory| {
            let mut output_b = output.borrow_mut();
            let len = output_b.len();

            output_b.copy_from_slice(
                memory
                    .get(*ptr.borrow(), len)
                    .map_err(|_| Error::Runtime)?
                    .as_slice(),
            );
            Ok(Some(()))
        }
    }
    fn return_value_no_buffer()
	    -> impl FnOnce(Option<RuntimeValue>, &MemoryRef) -> Result<Option<u32>, Error>
    {
        |res, _| {
            if let Some(I32(r)) = res {
                Ok(Some(r as u32))
            } else {
                Ok(None)
            }
        }
    }
    fn return_value_write_buffer(output: Rc<RefCell<Vec<u8>>>, ptr: Rc<RefCell<u32>>)
	    -> impl FnOnce(Option<RuntimeValue>, &MemoryRef) -> Result<Option<u32>, Error>
    {
        move |res, memory| {
            let mut output_b = output.borrow_mut();
            let len = output_b.len();

            if let Some(I32(r)) = res {
                output_b.copy_from_slice(
                    memory
                        .get(*ptr.borrow(), len)
                        .map_err(|_| Error::Runtime)?
                        .as_slice(),
                );

                Ok(Some(r as u32))
            } else {
                Ok(None)
            }
        }
    }
}